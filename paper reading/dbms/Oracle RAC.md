## Oracle RAC

### Cache Fusion

首先Oracle RAC是一个share everything的分布式数据库（既共享内存数据、又共享存储；也可以理解为share-disk + share-buffer）；那么内存共享就是通过Cache Fusion将数据从一个节点的bufferpool传到其它节点。

相关术语：

1. cache coherency：即维持 buffer中数据块在不同实例上的一致性

2. multi version consistency model：包括数据块的当前版本、以及其他读一致的版本。

   注意：当前版本包括已提交以及未提交的数据更新。比如用户在实例节点A更新了不存在于任何一个实例上的数据块，则该块会从底层磁盘读入缓冲区。如果另外一个实例B请求读取该数据块，此时Oracle会生成一个该块的Consistent Read副本(通过节点A的当前版本以及undo log生成)，并将该副本发送到请求实例上。

3. global cache service(GCS)：Cache Fusion 的核心组件。全局缓存服务负责了实例之间 数据块的传输，主要功能是**记录数据块的状态和存储位置**，需要维护全局缓存存储区内的缓存一致性，确保一个实例在任何时刻要修改一个数据块时，都会获得一个全局锁资源。

4. global enqueue service(GES)：包含了所有 非基于cache fushion的实例间操作，比如元数据的并发控制。

5. global resource directory(GRD)：GCS + GES 一起维护的全局资源，存放在每个实例的**SGA**中。GRD可以视作一个分布式内存数据库，存放的是cache中所有block 的信息。比如 某一块最新版本的存放位置，块的模式等。同时GRD是分布式的，也就是每个实例上会存放部分的数据（而非全量）。

两种共享模式：

1. Read-Sharing：查询存于其它节点的buffer。保证 某个数据块如果已被某节点读取过，则之后其它节点访问都不需要从磁盘读取。

   需要保障数据读取的一致性，本质是通过MVCC实现。

2. Write-Sharing：更新存于其它节点的buffer。节点A先通过GCS找到块的存放节点为B，节点B此时生成并保存该块的一个副本（用于自己的后续读），然后释放所有权（该块的ownership转交给节点A了，**A会给该块加上排它锁**，谁更新就是谁的所有权，块由其所有者进行刷脏），将该块发送给A（可能是脏块）。

节点间如何提高通信效率：

1. 使用定长的消息格式，并使用高速硬件加速网络传输（所以RAC部署需要专用物理机）
2. 一次buffer的获取永远只会涉及三个节点（请求节点、管理节点、持有节点），不会随着集群规模扩大而膨胀
3. 高频访问页面的元数据信息移至本地，减少对管理节点的重复访问

