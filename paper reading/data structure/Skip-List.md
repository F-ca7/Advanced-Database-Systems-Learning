## Skip Lists: Done Right

1. Skip list 是支持快速搜索的链表式结构。其主要优点，就是可以跟红黑树、AVL等平衡树一样，做到比较稳定地插入、查询与删除。理论插入查询删除的算法时间复杂度为O(logN)。但它比起平衡树的优点是 查询一个区间 和 删除一个区间很方便。

2. **问题**：最近几年人们对 跳表的性能持怀疑态度，因为跳表对cache的支持不如B树等结构。但是一个好的实现就可以解决这些问题，

3. 传统实现：

   ![](https://cchw-1257198376.cos.ap-chengdu.myqcloud.com/test/clipboard_20200227055939.png)

   相当于在最底部的链表中 跳着提取出一些结点作为 一级索引；再从一级索引中 跳着选一些作为二级索引…每个node都有自己的高度，比如'42'的高度为2，'53'的高度为3，'11'的高度为1。

   如果把上图的跳表顺时针旋转45°，再去除重复的边，就可以得到一个搜索二叉树：

   ![](https://cchw-1257198376.cos.ap-chengdu.myqcloud.com/test/clipboard_20200227060925.png)

   由于不需要实现自平衡 self-balancing，跳表的实现比红黑树等简单。

   实际实现中，垂直方向的连接不是链表；整个跳表只有一个单链表，而每个单链表的结点 是一个array(包含其上面的结点)。但如果使用动态数组的话，很容易发生cache miss，所以推荐固定代销的数组。

4. 优点：
   - 插入速度很快，不需要旋转等操作
   - 比自平衡树 和 哈希表 实现起来更容易
   - 可以在常数时间内取得下一个元素（二叉搜索树通过中序遍历取得下一个元素需要对数时间，哈希表需要线性时间）
   - 很容易修改跳表算法 来适应特定需求（如 带索引的跳表、带键的优先队列）
   - 无锁化很简单
   - 在持久化的存储中表现的更好（比起AVL树）

5. 对cache的支持

   - **Memory Pool**

   - **Flat Array**

   - **Unrolled List**

     ![](https://cchw-1257198376.cos.ap-chengdu.myqcloud.com/test/clipboard_20200227081231.png)