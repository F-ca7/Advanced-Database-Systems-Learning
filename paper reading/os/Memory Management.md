## 内存管理

1. 存储层次：

   1. 寄存器 (ns)
   2. CPU缓存 (10ns)
   3. 主存 (100ns)
   4. 外存 (ms)

   如果要达到极致的性能优化，就有必要关注L1、L2、L3的cache，比如nginx的绑核操作、pthread调度。

2. 从进程的角度来看，内存分为：**内核态**、**用户态** 两个部分。

   用户态的内存划分为：

   - Stack
   - Memory mapping segment
   - heap
   - bss segment（未初始化的全局变量和局部静态变量）
   - data segment（经过初始化的全局变量和局部静态变量）
   - text segment（程序源代码编译后的机器指令）

   内核态的内存划分为：

   - 直接映射的物理页帧
   - VMALLOC
   - 持久映射
   - 高端映射

3. 虚拟内存（逻辑上对程序物理内存的抽象）

   物理内存按大小被分成页框、页，每块物理内存可以被映射为一个或多个虚拟内存页。这块映射关系，由操作系统的页表来保存，页表是有层级的。层级最低的页表，保存实际页面的物理地址，较高层级的页表包含指向低层级页表的物理地址，指向顶级的页表的地址，驻留在寄存器中。

   每次访问可以使用更易理解的虚拟地址，让CPU转换成实际的物理地址访问内存，降低了直接使用、管理物理内存的门槛。

4. 驻留内存 Resident Memory

   指那些 **被映射到进程虚拟内存空间的 物理内存**。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存

5. TOP指令内存参数的区别

   - **VIRT**：进程的虚拟(地址)空间大小，其包含进程实际使用的大小(申请的堆栈)， 使用mmap映射的大小，包括外设RAM， 还有映射到本进程的文件（例如动态库)，还有进程间的共享内存。所以VIRT 表示的是**当前这个进程能够访问到的所有空间大小**
   - **RES**：表示**进程的常驻内存大小**，准确表示当前有多少物理内存被这个进程消费，这个和MEM是对应的， 这个大小永远要比VIRT小，因为程序大部分使用到c库。所以说，**看进程在运行过程中占用了多少内存应该看RES的值而不是VIRT的值**。
   - **SHR**：表示的是**进程占用的共享内存大小**，**多少VIRT 实际可以共享的**（包括内存和动态库），举例动态库，SHR的值不总代表整个库都是常驻内存的，因为有些程序使用到c库的部分函数，但整个库是被映射到进程的，并且计算到VIRT和SHR，但是只有该库的一部分被使用到

6. 举例：

   ![](https://cchw-1257198376.cos.ap-chengdu.myqcloud.com/test/clipboard_20200918105254.png)

   - A1、A2、A3和A4是进程A的驻留内存
   - B1、B2和B3是进程B的驻留内存
   - TOP中进程A的 *VIRT* 是**A1、A2、A3、A4以及灰色部分所有空间的总和**（上面的那块，不是系统物理内存的那块）
   - 而进程A虚拟内存空间中的A4和进程B虚拟内存空间中的B3都映射到了物理内存空间的A4/B3部分，是因为程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出**现不同进程的虚拟内存空间会映射到相同的物理内存空间**。也就是共享内存，用*SHR* 来表示。

7. 虚拟内存 和 swap分区

   windows的虚拟内存 对应 linux的swap分区，不同点在于windows即使物理内存没有用完也会去用到虚拟内存，而Linux不一样 Linux只有当物理内存用完的时候才会去动用swap分区。

   该篇笔记 虚拟内存 指的就是Linux的虚拟内存。

8. 虚拟内存的好处

   - 有助于**进程进行内存管理**：

     - 比如 进程访问内存时，都要通过页表来寻址，操作系统在页表的各个项目上添加各种访问权限标识位，就可以实现内存的权限控制
     - 每个进程都认为自己获取的内存是一块连续的地址，在编写应用程序时，就不用考虑大块地址的分配，总是认为系统有足够的大块内存即可

   - **数据共享**

     只需要将各个进程的虚拟内存地址指向系统分配的共享内存地址即可；从而同一个库不用加载两次

   - **swap**

     Linux 中可以使用 SWAP 分区，在分配物理内存，但可用内存不足时，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中

9. 多线程对虚拟内存的消耗

   每个线程都有自己的缓冲区来解决多线程内存分配的竞争，比如在JVM中：

   - 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
   - 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配
   - TLAB是在 Eden区开辟的一小块线程私有区域 （TLAB大小取决于Eden space的大小）

10. 内存工具：
    - Valgrind：由内核以及基于内核的其他调试工具组成。内核类似于一个框架，它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件，利用内核提供的服务完成各种特定的内存调试任务。（可用来检测**内存泄漏**）
    - strace：跟踪系统调用的执行。最简单的方式，它可以从头到尾跟踪binary的执行，然后以一行文本输出系统调用的名字，参数和返回值。（可以用来看对于内存相关的系统函数调用）
    - MAT：JVM工具，通过堆得dump，来分析内存使用、对象引用等情况

------------

1. 堆和栈的区别

   |          | 栈                                                           | 堆                                                           |
   | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 管理方式 | 操作系统自动分配                                             | 程序人员控制                                                 |
   | 空间     | 向低地址扩展，栈顶的地址和栈的最大容量是系统预先规定好的     | 高地址扩展。通常系统是用链表来存储空闲内存地址的。           |
   | 分配效率 | 高。操作系统提供的，会在底层堆栈提供支持，分配专门的寄存器存放栈的地址，包括压栈出栈也都有专门的指令执行 | 较低。例如分配一块内存，库函数会按照一定的算法在堆内存空间中搜索可用的足够大的内存空间，如果没有足够大的连续空间，则需要操作系统来重新整理堆内存，这样才有机会分到足够大小的空间，然后才返回 |

   